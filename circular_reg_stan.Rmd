---
title: "Circular Regression Stan"
author: "kotsubo takuto"
date: "2018年6月1日"
output: 
    html_document:
      md_extensions: -ascii_identifiers
      toc: true
      toc_depth: 3
---

# set 

```{r option, echo=FALSE, cache=FALSE, warning=FALSE}
rm(list = ls())
setwd("~/Desktop/circular_reg/") 
library(knitr)
## Global options
options(max.print="75", digits=5)
opts_chunk$set(echo=TRUE,
               cache = FALSE, # 現状大きな計算はしていないので
	             prompt=FALSE,
               tidy=TRUE,
               comment=NA,
               message=FALSE,
               warning=FALSE)
opts_knit$set(width=75)
```

# install package

```{r,echo=FALSE}
library(dplyr)
library(tidyverse)
library(tibble)
library(lubridate)
library(circular)
library(readr)
library(ggthemes)
library(vars)
library(MASS)
library(rstan)
library(MCMCpack)
library(loo)
```

# Function

```{r}
# 結果のベクトルを抽出 var(1)
ans_stan <- function(fit,num,data){
  fit_ext <- rstan::extract(fit,permuted=T)
  # Const parameter
  alpha_0 = matrix(c(fit_ext$alpha_0[,1] %>% mean(),fit_ext$alpha_0[,2] %>% mean()),ncol=1)
  # Beta parameter
  alpha_1 = matrix(c(fit_ext$alpha_1[,1,1] %>% mean(),fit_ext$alpha_1[,1,2] %>% mean(),
                     fit_ext$alpha_1[,2,1] %>% mean(),1),ncol=2)
  # mu = matrix(c(fit_ext$mu[,1] %>% mean(),fit_ext$mu[,2] %>% mean()),ncol=1)
  Sigma = matrix(c(fit_ext$sigma[,1,1] %>% mean(),fit_ext$sigma[,1,2] %>% mean(),
                   fit_ext$sigma[,2,1] %>% mean(),fit_ext$sigma[,2,2] %>% mean()),ncol=2)
    # 誤差項を計算, 正規乱数を計算した後にノルムで割って正規化する
  set.seed(31) # ランダムシード
  eps <- mvrnorm(1,c(0,0),Sigma) %>% 
    {. / ( sqrt(t(.) %*% .) %>% as.numeric() )}
  Ans <- c()
  for(i in 2:num){
    ans <- alpha_0+ (alpha_1 %*% matrix(c(cos(data[i-1]),sin(data[i-1])),ncol=1)) + eps
    Ans <- rbind(Ans,t(ans))
  }
  return(Ans)  
}

# 結果のベクトルを抽出 VAR(p)
ans_stan_p <- function(fit,P,num,data){
  # 得られたモデルを抽出する
  fit_ext <- rstan::extract(fit,permuted=T)
  # 格納する変数を用意する
  alpha_1 <- c()
  # Const parameter
  alpha_0 = matrix(c(fit_ext$alpha_0[,1] %>% mean(),fit_ext$alpha_0[,2] %>% mean()),ncol=1)
  # Beta parameter
  for(i in 1:P){
    tmp <- matrix(c(fit_ext$alpha_1[,1,2*i-1] %>% mean(),fit_ext$alpha_1[,1,2*i] %>% mean(),
                    fit_ext$alpha_1[,2,2*i-1] %>% mean(),fit_ext$alpha_1[,1,2*i] %>% mean()),ncol=2)
    alpha_1 <- cbind(alpha_1, tmp)
  }
  # Variance-Covariance matrix
  Sigma = matrix(c(fit_ext$sigma[,1,1] %>% mean(),fit_ext$sigma[,1,2] %>% mean(),
                   fit_ext$sigma[,2,1] %>% mean(),fit_ext$sigma[,2,2] %>% mean()),ncol=2)
  # 誤差項を計算, 正規乱数を計算した後にノルムで割って正規化する
  set.seed(31) # ランダムシード
  eps <- mvrnorm(1,c(0,0),Sigma) %>% 
    {. / ( sqrt(t(.) %*% .) %>% as.numeric() )}

  Ans <- c(); # 予測値を格納する
  for(i in 1+P:num){
    pre <- c(); # p期前のcos(theta), sin(theta)を格納する
    for (k in 1:P) {
      tmp <- matrix(c(cos(data[i-k]),sin(data[i-k])),ncol=1)
      pre <- rbind(pre,tmp)
      }
    ans <- alpha_0 + (alpha_1 %*% pre) + eps
    Ans <- rbind(Ans,t(ans))
  }
  return(Ans)  
}
```

# dataset

```{r}
# dataset we report the wind direction recorded every day from January 29, 2001 to March 31, 2001 from 3.00am to 4.00am included.
# 角度データなので, 周期性を考えて, 0がモード付近になるようにシフトさせる. 元データから$-\pi$ずらして, $[-\pi,\pi]$で考える.
data(wind) 
wind_data <- wind %>%  
  data.frame(t = seq(1,310,1), tmp=.) %>% # put label
  mutate(theta_real = dplyr::if_else(tmp>pi,tmp - 2*pi, tmp)) %>% 
  dplyr::select(-tmp) %>% 
  mutate(cos_real = cos(theta_real), sin_real=sin(theta_real))
```

# stan code

## stan test

```{r stan test, eval=FALSE}
d.dat1 <- list(N=length(wind_data$theta_real),theta=wind_data$theta_real) # for VAR(1)
d.dat2 <- list(N=length(wind_data$theta_real),P=2,theta=wind_data$theta_real) # for VAR(p)
#fit<-stan(file='stan/test.stan',data=d.dat,iter=1000,chains=1) # sigma(2,2) に対して1を仮定する
#fit<-stan(file='stan/test1.stan',data=d.dat,iter=4000,chains=1) # 分散共分散行列の過程
model1 <- stan_model('stan/circularVAR_1.stan')
fit1 <- sampling(model1, data = d.dat1, iter=500, chains=1) # 分散共分散行列の過程
model2 <- stan_model('stan/circularVAR_p.stan') # compile
fit2 <- sampling(model2, data = d.dat2, iter=500, chains=1) # Execute model 
```

## stan parallel processing code

```{r stan Parallel processing, eval=FALSE}
rstan_options(auto_write=TRUE) # auto save
options(mc.cores=parallel::detectCores()) # multi core

model <- model <- stan_model('stan/circularVAR_p.stan') # compile
fit <- sampling(model, 
                data = d.dat,
                iter = 5000,
                chains = 4,
                thin =2,
                open_progress = TRUE)
```


```{r stan save model and fit,eval=FALSE}
saveRDS(model, "model/circularVAR_p.rds") # save model
save(fit1, file="fit/circularVAR_1.rda")# save fit
save(fit2, file="fit/circularVAR_2.rda")# save fit
```

```{r stan load model and fit}
# model <- readRDS("model/circularVAR_p.rds") # load model
load("fit/circularVAR_1.rda", verbose = TRUE) # load fit
load("fit/circularVAR_2.rda", verbose = TRUE) # load fit
```

# output predict value

```{r}
data_ans1 <- ans_stan(fit1,num = length(wind_data$theta_real),data=wind_data$theta_real) # パラメータ推定値を用いて, 予測 
data_ans2 <- ans_stan_p(fit2, P=2, num = length(wind_data$theta_real),data=wind_data$theta_real) # パラメータ推定値を用いて, 予測 

data_ans1 %>%  # var(1)
  as_data_frame() %>% 
  mutate(t = seq(1,length(data_ans1)/2,1)) %>% 
  tidyr::gather(key = "variable",value  = value, V1,V2) %>% 
  ggplot(aes(x=t,y=value,colour=variable)) +
  geom_line() + 
  theme_economist() +
  labs(title = "time series circular plot")

data_ans2 %>% # var(p)
  as_data_frame() %>% 
  mutate(t = seq(1,length(data_ans2)/2,1)) %>% 
  tidyr::gather(key = "variable",value  = value, V1,V2) %>% 
  ggplot(aes(x=t,y=value,colour=variable)) +
  geom_line() + 
  theme_economist() +
  labs(title = "time series circular plot")
```

# Diagnosis

```{r}
stan_trace(fit1)
stan_ac(fit1)

stan_trace(fit2)
stan_ac(fit2)
```

# Estimate loglikelihood and waic

```{r}
log_lik1 <- extract_log_lik(fit1,"log_likelihood")
loo::waic(log_lik1)
```


