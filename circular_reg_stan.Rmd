---
title: "Circular Regression Stan"
author: "kotsubo takuto"
date: "2018年6月1日"
output: 
    html_document:
      md_extensions: -ascii_identifiers
      toc: true
      toc_depth: 3
---

# set 

```{r option, echo=FALSE, cache=FALSE, warning=FALSE}
rm(list = ls())
setwd("~/Desktop/circular_reg/") 
library(knitr)
## Global options
options(max.print="75", digits=5)
opts_chunk$set(echo=TRUE,
               cache = FALSE, # 現状大きな計算はしていないので
	             prompt=FALSE,
               tidy=TRUE,
               comment=NA,
               message=FALSE,
               warning=FALSE)
opts_knit$set(width=75)
```

# install package

```{r,echo=FALSE}
library(dplyr)
library(tidyverse)
library(tibble)
library(lubridate)
library(circular)
library(readr)
library(ggthemes)
library(vars)
library(MASS)
library(rstan)
library(MCMCpack)
library(loo)
```

# Function

```{r}
# Projected Normal Circular Plobability Density 
dPnCircular_dens <- function(theta,mu,Sigma){
 u = matrix(c(cos(theta),sin(theta)),ncol=1)
 A = t(u) %*% solve(Sigma) %*% u
 B = t(u) %*% solve(Sigma) %*% mu
 C = (-1/2) * (t(mu) %*% solve(Sigma) %*% mu)
 tmp = B/sqrt(A)
 p = as.numeric((1/(2*pi*A*sqrt(det(Sigma)))) * exp(C) *
   (1 + tmp*pnorm(tmp,0,1)/dnorm(tmp,0,1)))
 return(p)
}
# Vectorize 関数
v.dPnCircular_dens <- Vectorize(dPnCircular_dens, "theta") 

# 結果のベクトルを抽出 VAR(p)
ans_stan_p <- function(fit,P,num,data){
  # 得られたモデルを抽出する
  fit_ext <- rstan::extract(fit,permuted=T)
  # 格納する変数を用意する
  alpha_1 <- c()
  # Const parameter
  alpha_0 = matrix(c(fit_ext$alpha_0[,1] %>% mean(),fit_ext$alpha_0[,2] %>% mean()),ncol=1)
  # Beta parameter
  for(i in 1:P){
    tmp <- matrix(c(fit_ext$alpha_1[,1,2*i-1] %>% mean(),fit_ext$alpha_1[,1,2*i] %>% mean(),
                    fit_ext$alpha_1[,2,2*i-1] %>% mean(),fit_ext$alpha_1[,1,2*i] %>% mean()),ncol=2)
    alpha_1 <- cbind(alpha_1, tmp)
  }
  # Variance-Covariance matrix
  Sigma_hat = matrix(c(fit_ext$sigma[,1,1] %>% mean(),fit_ext$sigma[,1,2] %>% mean(),
                       fit_ext$sigma[,2,1] %>% mean(),fit_ext$sigma[,2,2] %>% mean()),ncol=2)
  # Sigma_hat = matrix(c(1,0,0,1),ncol=2) # for model3
  # Estimate condition mean 
  mu_hat <- matrix(0, ncol=2, nrow=(num-P) )
  for(i in (1+P):num){
    pre <- c(); # p期前のcos(theta), sin(theta)を格納する
    for (k in 1:P) {
      tmp <- matrix(c(cos(data[i-k]),sin(data[i-k])),ncol=1)
      pre <- rbind(pre,tmp)
      }
    mu_hat[i-P,] <- alpha_0 + ( alpha_1 %*% pre )
  }
  # Estimate moment
  fn.sin<-function(x,mu,Sigma) sin(x)*v.dPnCircular_dens(theta=x, mu, Sigma) # sin func
  fn.cos<-function(x,mu,Sigma) cos(x)*v.dPnCircular_dens(theta=x, mu, Sigma) # cos func
  # Estimate parameter
  len <- dim(mu_hat)[1]; sin.mom <- cos.mom<- c();
  # 
  for(i in 1:len){
   sin.mom[i] <- integrate(fn.sin, lower=-pi, upper=pi,
                           mu=mu_hat[i,], Sigma=Sigma_hat)$value
   cos.mom[i] <- integrate(fn.cos, lower=-pi, upper=pi,
                           mu=mu_hat[i,], Sigma=Sigma_hat)$value
  }
  pred <- atan2(sin.mom,cos.mom)
  return(pred)  
}
# output predict value
pred_value <- function(fit,p,dat){
  pred <- ans_stan_p(fit, P=p, num = length(dat),data=dat) # パラメータ推定値を用いて, 予測
  matplot(cbind(dat[-c(1:p)],pred),type="l")
}
```

# dataset

```{r}
# dataset we report the wind direction recorded every day from January 29, 2001 to March 31, 2001 from 3.00am to 4.00am included.
# 角度データなので, 周期性を考えて, 0がモード付近になるようにシフトさせる. 元データから$-\pi$ずらして, $[-\pi,\pi]$で考える.
data(wind) 
wind_data <- wind %>%  
  data.frame(t = seq(1,310,1), tmp=.) %>% # put label
  mutate(theta_real = dplyr::if_else(tmp>pi,tmp - 2*pi, tmp)) %>% 
  dplyr::select(-tmp) %>% 
  mutate(cos_real = cos(theta_real), sin_real=sin(theta_real))
```

# stan code

model1 : const paramterにnorm1の制約を付与
model2 : 全ての係数パラメータに-1 ~ 1の制約を付与

## stan test

```{r set data list, eval=FALSE}
d.dat1 <- list(N=length(wind_data$theta_real),P=1,theta=wind_data$theta_real) # for VAR(1)
d.dat2 <- list(N=length(wind_data$theta_real),P=2,theta=wind_data$theta_real) # for VAR(2)
d.dat3 <- list(N=length(wind_data$theta_real),P=3,theta=wind_data$theta_real) # for VAR(3)
```

```{r stan test, eval=FALSE,include=FALSE}
#fit<-stan(file='stan/test.stan',data=d.dat,iter=1000,chains=1) # sigma(2,2) に対して1を仮定する
#fit<-stan(file='stan/test1.stan',data=d.dat,iter=4000,chains=1) # 分散共分散行列の過程
# compile model
model1 <- stan_model('stan/circularVAR_p.stan')
model2 <- stan_model('stan/circularVAR_p_.stan')
model3 <- stan_model('stan/circularVAR_p_I.stan')
model4 <- stan_model('stan/circularVAR_p_penalty.stan')
# fitting stan model
fit1_1 <- sampling(model1, data = d.dat1, iter=1000, chains=1) # Execute model
fit2_1 <- sampling(model1, data = d.dat2, iter=1000, chains=1) # Execute model 
fit1_2 <- sampling(model2, data = d.dat1, iter=1000, chains=1) # Execute model
fit2_2 <- sampling(model2, data = d.dat2, iter=1000, chains=1) # Execute model
fit1_3 <- sampling(model3, data = d.dat1, iter=1000, chains=1) # Execute model
fit2_3 <- sampling(model3, data = d.dat2, iter=1000, chains=1) # Execute model
fit1_4 <- sampling(model4, data = c(d.dat1,lambda=0.5), iter=1000, chains=1) # Execute model
fit2_4 <- sampling(model4, data = c(d.dat2,lambda=0.5), iter=1000, chains=1) # Execute model
fit3_4 <- sampling(model4, data = c(d.dat3,lambda=0.1), iter=1000, chains=1) # Execute model
```

## stan parallel processing code

```{r stan Parallel processing, eval=FALSE,include=FALSE}
rstan_options(auto_write=TRUE) # auto save
options(mc.cores=parallel::detectCores()) # multi core

model <- model <- stan_model('stan/circularVAR_p.stan') # compile
fit <- sampling(model, 
                data = d.dat,
                iter = 5000,
                chains = 4,
                thin =2,
                open_progress = TRUE)
```


```{r stan save model and fit,eval=FALSE,include=FALSE}
saveRDS(model1, "model/circularVAR_p_1.rds") # save model
saveRDS(model2, "model/circularVAR_p_2.rds") # save model
save(fit1_1, file="fit/circularVAR_1_1.rda")# save fit
save(fit2_1, file="fit/circularVAR_2_1.rda")# save fit
save(fit1_2, file="fit/circularVAR_1_2.rda")# save fit
save(fit2_2, file="fit/circularVAR_2_2.rda")# save fit
```

```{r stan load model and fit}
model1 <- readRDS("model/circularVAR_p_1.rds") # load model
model2 <- readRDS("model/circularVAR_p_2.rds") # load model
load("fit/circularVAR_1_1.rda", verbose = TRUE) # load fit
load("fit/circularVAR_2_1.rda", verbose = TRUE) # load fit
load("fit/circularVAR_1_2.rda", verbose = TRUE) # load fit
load("fit/circularVAR_2_2.rda", verbose = TRUE) # load fit
```

# output fit paremter

```{r}
options(max.print = 200)
fit1_1 # model1, VAR(1)model
fit2_1 # model1, VAR(2)model
fit1_2 # model2, VAR(1)model
fit2_2 # model2, VAR(2)model
fit1_4 # model4
fit3_4 # model4
```

# output predict value

```{r}
# model1
pred_value(fit = fit1_1,p = 1,dat=wind_data$theta_real)
pred_value(fit = fit2_1,p = 2,dat=wind_data$theta_real)

#model2
pred_value(fit = fit1_2,p = 1,dat=wind_data$theta_real)
pred_value(fit = fit2_2,p = 2,dat=wind_data$theta_real)

#model3
pred_value(fit = fit1_3,p = 1,dat=wind_data$theta_real) # function 内部 変更の必要あり
pred_value(fit = fit2_3,p = 2,dat=wind_data$theta_real) # function 内部 変更の必要あり

#model4
pred_value(fit = fit1_4,p = 1,dat=wind_data$theta_real)
pred_value(fit = fit2_4,p = 2,dat=wind_data$theta_real)
pred_value(fit = fit3_4,p = 3,dat=wind_data$theta_real)
```

# Diagnosis

```{r}
# model1
stan_trace(fit1_1)
stan_ac(fit1_1)
stan_trace(fit2_1)
stan_ac(fit2_1)

#model2
stan_trace(fit1_2)
stan_ac(fit1_2)
stan_trace(fit2_2)
stan_ac(fit2_2)

#model2
stan_trace(fit1_3)
stan_ac(fit1_3)
stan_trace(fit2_3)
stan_ac(fit2_3)
```

# Estimate loglikelihood and waic

```{r}
# model1
log_lik1 <- extract_log_lik(fit1_1,"log_likelihood")
loo::waic(log_lik1)
log_lik2 <- extract_log_lik(fit2_1,"log_likelihood")
loo::waic(log_lik2)

# model2
log_lik1 <- extract_log_lik(fit1_2,"log_likelihood")
loo::waic(log_lik1)
log_lik2 <- extract_log_lik(fit2_2,"log_likelihood")
loo::waic(log_lik2)

# model3
log_lik1 <- extract_log_lik(fit1_3,"log_likelihood")
loo::waic(log_lik1)
log_lik2 <- extract_log_lik(fit2_3,"log_likelihood")
loo::waic(log_lik2)
```


