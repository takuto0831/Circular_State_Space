---
title: "Circular Regression Stan"
author: "kotsubo takuto"
date: "2018年6月1日"
output: 
    html_document:
      md_extensions: -ascii_identifiers
      toc: true
      toc_depth: 3
---

# set 

```{r option, echo=FALSE, cache=FALSE, warning=FALSE}
rm(list = ls())
setwd("~/Desktop/circular_reg/") 
library(knitr)
## Global options
options(max.print="75", digits=5)
opts_chunk$set(echo=TRUE,
               cache = FALSE, # 現状大きな計算はしていないので
	             prompt=FALSE,
               tidy=TRUE,
               comment=NA,
               message=FALSE,
               warning=FALSE)
opts_knit$set(width=75)
```


# install package

```{r,echo=FALSE}
library(dplyr)
library(tidyverse)
library(tibble)
library(lubridate)
library(circular)
library(readr)
library(ggthemes)
library(vars)
library(MASS)
library(rstan)
library(MCMCpack)
library(loo)
```

# Function

```{r}
# Projected Normal Circular Plobability Density 
dPnCircular_dens <- function(theta,mu,Sigma){
 u = matrix(c(cos(theta),sin(theta)),ncol=1)
 A = t(u) %*% solve(Sigma) %*% u
 B = t(u) %*% solve(Sigma) %*% mu
 C = (-1/2) * (t(mu) %*% solve(Sigma) %*% mu)
 tmp = B/sqrt(A)
 p = as.numeric((1/(2*pi*A*sqrt(det(Sigma)))) * exp(C) *
   (1 + tmp*pnorm(tmp,0,1)/dnorm(tmp,0,1)))
 return(p)
}
# Vectorize 関数
v.dPnCircular_dens <- Vectorize(dPnCircular_dens, "theta") 

# 結果のベクトルを抽出 VAR(p)
ans_stan_p <- function(fit,P,num,data){
  # 得られたモデルを抽出する
  fit_ext <- rstan::extract(fit,permuted=T)
  # 格納する変数を用意する
  alpha_1 <- c()
  # Const parameter
  alpha_0 = matrix(c(fit_ext$alpha_0[,1] %>% mean(),fit_ext$alpha_0[,2] %>% mean()),ncol=1)
  # alpha_0 = matrix(c(0,0),ncol = 1) ######################### debug ######################
  # Beta parameter
  for(i in 1:P){
    tmp <- matrix(c(fit_ext$alpha_1[,1,2*i-1] %>% mean(),fit_ext$alpha_1[,1,2*i] %>% mean(),
                    fit_ext$alpha_1[,2,2*i-1] %>% mean(),fit_ext$alpha_1[,1,2*i] %>% mean()),ncol=2)
    alpha_1 <- cbind(alpha_1, tmp)
  }
  # Variance-Covariance matrix
  Sigma_hat = matrix(c(fit_ext$sigma[,1,1] %>% mean(),fit_ext$sigma[,1,2] %>% mean(),
                       fit_ext$sigma[,2,1] %>% mean(),fit_ext$sigma[,2,2] %>% mean()),ncol=2)
  # Sigma_hat = matrix(c(1,0,0,1),ncol=2) # for model3
  # Estimate condition mean 
  mu_hat <- matrix(0, ncol=2, nrow=(num-P) )
  for(i in (1+P):num){
    pre <- c(); # p期前のcos(theta), sin(theta)を格納する
    for (k in 1:P) {
      tmp <- matrix(c(cos(data[i-k]),sin(data[i-k])),ncol=1)
      pre <- rbind(pre,tmp)
      }
    mu_hat[i-P,] <- alpha_0 + ( alpha_1 %*% pre )
  }
  # Estimate moment
  fn.sin<-function(x,mu,Sigma) sin(x)*v.dPnCircular_dens(theta=x, mu, Sigma) # sin func
  fn.cos<-function(x,mu,Sigma) cos(x)*v.dPnCircular_dens(theta=x, mu, Sigma) # cos func
  # Estimate parameter
  len <- dim(mu_hat)[1]; sin.mom <- cos.mom<- c();
  # Estimate expected value
  for(i in 1:len){
   sin.mom[i] <- integrate(fn.sin, lower=-pi, upper=pi,
                           mu=mu_hat[i,], Sigma=Sigma_hat)$value
   cos.mom[i] <- integrate(fn.cos, lower=-pi, upper=pi,
                           mu=mu_hat[i,], Sigma=Sigma_hat)$value
  }
  # Estimate predict theta value
  pred <- atan2(sin.mom,cos.mom)
  return(pred)  
}
# output predict value
pred_value <- function(fit,p,dat){
  pred <- ans_stan_p(fit, P=p, num = length(dat),data=dat) # パラメータ推定値を用いて, 予測
  matplot(cbind(dat[-c(1:p)],pred),type="l") # 真値の初期値をずらす
}
```

# dataset

```{r}
# dataset we report the wind direction recorded every day from January 29, 2001 to March 31, 2001 from 3.00am to 4.00am included.
# 角度データなので, 周期性を考えて, 0がモード付近になるようにシフトさせる. 元データから$-\pi$ずらして, $[-\pi,\pi]$で考える.
data(wind) 
wind_data <- wind %>%  
  data.frame(t = seq(1,310,1), tmp=.) %>% # put label
  mutate(theta_real = dplyr::if_else(tmp>pi,tmp - 2*pi, tmp)) %>% 
  dplyr::select(-tmp) %>% 
  mutate(cos_real = cos(theta_real), sin_real=sin(theta_real))
```

# check stan funcion

stan 尤度関数が機能しているか確認する

```{r}
rstan::expose_stan_functions("stan/test.stan")
```

```{r likelihood}
# Projected Normal AutoRegressive Process
l_ <- function(arg){
 num <- length(data)
 a0 <- arg[1]; b0 <- arg[4];
 a11 <- arg[2]; a12 <- arg[3]
 b11 <- arg[5]; b12 <- arg[6]
 sigma1 <- exp(arg[7]); sigma2 <- exp(arg[8]); rho <- tanh(arg[9]) # 数値を-1 ~ 1に抑え込む
 sigma <- matrix(c(sigma1^2, rho*sigma1*sigma2,rho*sigma1*sigma2, sigma2^2 ),2,2)
 alpha_0 =  matrix(c(a0,b0), ncol=1); alpha_1 = matrix(c(a11,b11, a12,b12), ncol=2, nrow=2); 
 likelihood <- c(0) 
 for(i in 2:num){
   theta = data[i]; pre_theta = data[i-1]; 
   likelihood <- append(likelihood, circular_reg_lpdf(theta, pre_theta, alpha_0, alpha_1, sigma))
 }
 # print(solve(Sig)) #debug用
 # print(arg[8]) #debug用
 - sum(likelihood) # -1を乗じることで, 最大化問題を最小化問題にする.
}
```

```{r}
#初期値の目安はcircular-circular regressionで
lm.out <- lm.circular(y=wind_data$theta_real[-1], x=wind_data$theta_real[-310],order=1 )
par <- c(lm.out$coefficients[,1], 
         lm.out$coefficients[,2],
         log(var(cos(lm.out$residuals))), # 不偏分散 cos
         log(var(sin(lm.out$residuals))), # 不偏分散 sin
         atanh(cor(cos(lm.out$residuals),sin(lm.out$residuals)))) #相関係数
data=wind_data$theta_real
l_(par)
```

# stan code

model1 : const paramterにnorm1の制約を付与
model2 : 全ての係数パラメータに-1 ~ 1の制約を付与

罰則をなくすと, 滑らかになる?

## stan test

```{r set data list, eval=FALSE}
d.dat1 <- list(N=length(wind_data$theta_real),P=1,theta=wind_data$theta_real) # for VAR(1)
d.dat2 <- list(N=length(wind_data$theta_real),P=2,theta=wind_data$theta_real) # for VAR(2)
d.dat3 <- list(N=length(wind_data$theta_real),P=3,theta=wind_data$theta_real) # for VAR(3)
d.dat4 <- list(N=length(wind_data$theta_real),P=4,theta=wind_data$theta_real) # for VAR(3)
```

```{r stan test, eval=FALSE,include=FALSE}
#fit<-stan(file='stan/test.stan',data=d.dat,iter=1000,chains=1) # sigma(2,2) に対して1を仮定する
#fit<-stan(file='stan/test1.stan',data=d.dat,iter=4000,chains=1) # 分散共分散行列の過程
# compile model
model1 <- stan_model('stan/circularVAR_p.stan')
model2 <- stan_model('stan/circularVAR_p_.stan')
# model3 <- stan_model('stan/circularVAR_p_I.stan') # 趣旨とずれる
model4 <- stan_model('stan/circularVAR_p_penalty.stan')
model5 <- stan_model('stan/circularVAR_p_noconst.stan')

# fitting stan model
# fit1_1 <- sampling(model1, data = d.dat1, iter=1000, chains=1) # Execute model
# fit2_1 <- sampling(model1, data = d.dat2, iter=1000, chains=1) # Execute model 
fit1_2 <- sampling(model2, data = d.dat1, iter=1000, chains=1) # Execute model
fit2_2 <- sampling(model2, data = d.dat2, iter=1000, chains=1) # Execute model
fit3_2 <- sampling(model2, data = d.dat3, iter=1000, chains=1) # Execute model

fit1_3 <- sampling(model3, data = d.dat1, iter=1000, chains=1) # Execute model
fit2_3 <- sampling(model3, data = d.dat2, iter=1000, chains=1) # Execute model
fit1_4 <- sampling(model4, data = c(d.dat1,lambda=0), iter=2000, chains=1) # Execute model
fit2_4 <- sampling(model4, data = c(d.dat2,lambda=0.01), iter=1000, chains=1) # Execute model
fit3_4 <- sampling(model4, data = c(d.dat3,lambda=0.01), iter=1000, chains=1) # Execute model
fit4_4 <- sampling(model4, data = c(d.dat4,lambda=1), iter=1000, chains=1) # Execute model
fit1_5 <- sampling(model5, data = d.dat1, iter=1000, chains=1) # Execute model
fit2_5 <- sampling(model5, data = d.dat2, iter=1000, chains=1) # Execute model
fit3_5 <- sampling(model5, data = d.dat3, iter=1000, chains=1) # Execute model

# lambda = 0とすれば, 罰則なしの最尤法
fit3_2 <- sampling(model4, data = c(d.dat3,lambda=0), iter=1000, chains=1) # Execute model
fit4_2 <- sampling(model4, data = c(d.dat4,lambda=0), iter=1000, chains=1) # Execute model


```

## stan parallel processing code

```{r stan Parallel processing, eval=FALSE,include=FALSE}
rstan_options(auto_write=TRUE) # auto save
options(mc.cores=parallel::detectCores()) # multi core

# model <- stan_model('stan/circularVAR_p.stan') # compile
fit <- sampling(model4, 
                data = c(d.dat2,lambda=0.5),
                iter = 5000,
                chains = 4,
                thin =2)
```

```{r stan save model and fit,eval=FALSE,include=FALSE}
saveRDS(model1, "model/circularVAR_p_1.rds") # save model
saveRDS(model2, "model/circularVAR_p_2.rds") # save model
save(fit1_1, file="fit/circularVAR_1_1.rda")# save fit
save(fit2_1, file="fit/circularVAR_2_1.rda")# save fit
save(fit1_2, file="fit/circularVAR_1_2.rda")# save fit
save(fit2_2, file="fit/circularVAR_2_2.rda")# save fit
```

```{r stan load model and fit,eval=FALSE,include=FALSE}
model1 <- readRDS("model/circularVAR_p_1.rds") # load model
model2 <- readRDS("model/circularVAR_p_2.rds") # load model
load("fit/circularVAR_1_1.rda", verbose = TRUE) # load fit
load("fit/circularVAR_2_1.rda", verbose = TRUE) # load fit
load("fit/circularVAR_1_2.rda", verbose = TRUE) # load fit
load("fit/circularVAR_2_2.rda", verbose = TRUE) # load fit
```

# output fit paremter

```{r,eval=FALSE,include=FALSE}
options(max.print = 200)
fit1_1 # model1, VAR(1)model
fit2_1 # model1, VAR(2)model
fit1_2 # model2, VAR(1)model
fit2_2 # model2, VAR(2)model
fit1_4 # model4
fit3_4 # model4
```

# output predict value

```{r,eval=FALSE,include=FALSE}
# model1
# pred_value(fit = fit1_1,p = 1,dat=wind_data$theta_real)
# pred_value(fit = fit2_1,p = 2,dat=wind_data$theta_real)

#model2
pred_value(fit = fit1_2,p = 1,dat=wind_data$theta_real)
pred_value(fit = fit2_2,p = 2,dat=wind_data$theta_real)
pred_value(fit = fit3_2,p = 3,dat=wind_data$theta_real)

#model3
pred_value(fit = fit1_3,p = 1,dat=wind_data$theta_real) # function 内部 変更の必要あり
pred_value(fit = fit2_3,p = 2,dat=wind_data$theta_real) # function 内部 変更の必要あり

#model4
pred_value(fit = fit1_4,p = 1,dat=wind_data$theta_real)
pred_value(fit = fit2_4,p = 2,dat=wind_data$theta_real)
pred_value(fit = fit3_4,p = 3,dat=wind_data$theta_real)
pred_value(fit = fit4_4,p = 4,dat=wind_data$theta_real)

# model5
pred_value(fit = fit1_5,p = 1,dat=wind_data$theta_real)
pred_value(fit = fit2_5,p = 2,dat=wind_data$theta_real)
pred_value(fit = fit3_5,p = 3,dat=wind_data$theta_real)

```

# Diagnosis

```{r,eval=FALSE,include=FALSE}
shinystan::launch_shinystan(fit1_2)
get_posterior_mean(fit1_2)
get_inits(fit1_2)
```

```{r}
log_lik <- c()
a <- extract_log_lik(fit1_5,"log_likelihood")
for( i in 1:dim(a)[1]) {
  log_lik <- append(log_lik,a[i,] %>% sum()) 
}
max(log_lik)
min(log_lik)
mean(log_lik)
hist(log_lik)
```

```{r,eval=FALSE,include=FALSE}
# model1
stan_trace(fit1_1)
stan_ac(fit1_1)
stan_trace(fit2_1)
stan_ac(fit2_1)

#model2
stan_trace(fit1_2)
stan_ac(fit1_2)
stan_trace(fit2_2)
stan_ac(fit2_2)

#model2
stan_trace(fit1_3)
stan_ac(fit1_3)
stan_trace(fit2_3)
stan_ac(fit2_3)
```

# Estimate loglikelihood and waic

```{r,eval=FALSE,include=FALSE}
# model1
log_lik1 <- extract_log_lik(fit1_1,"log_likelihood")
loo::waic(log_lik1)
log_lik2 <- extract_log_lik(fit2_1,"log_likelihood")
loo::waic(log_lik2)

# model2
log_lik1 <- extract_log_lik(fit1_2,"log_likelihood")
loo::waic(log_lik1)
log_lik2 <- extract_log_lik(fit2_2,"log_likelihood")
loo::waic(log_lik2)

# model3
extract_log_lik(fit3_2,"log_likelihood") %>% loo::waic()
extract_log_lik(fit3_5,"log_likelihood") %>% loo::waic()

# model4
log_lik1 <- extract_log_lik(fit4_2,"log_likelihood")
loo::waic(log_lik1)
log_lik2 <- extract_log_lik(fit4_4,"log_likelihood")
loo::waic(log_lik2)

# model5
extract_log_lik(fit2_5,"log_likelihood") %>% loo::waic()
extract_log_lik(fit3_5,"log_likelihood") %>% loo::waic()
```


## for knitr 

```{r}
# set value
model <- stan_model('stan/circularVAR_p_penalty.stan')
d.dat2 <- list(N=length(wind_data$theta_real),P=2,theta=wind_data$theta_real) # for VAR(2)
for(i in 1:2){
  fit <- sampling(model, data = c(d.dat2,lambda=0.1*i), iter=1000, chains=1) # Execute model
  sprintf("lambda=%.2f",0.1*i) %>% print()
  extract_log_lik(fit,"log_likelihood") %>% loo::waic() %>% print()
  pred_value(fit = fit,p = 2,dat=wind_data$theta_real)
}
```







