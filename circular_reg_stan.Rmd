---
title: "Circular Regression Stan"
author: "kotsubo takuto"
date: "2018年6月1日"
output: 
    html_document:
      md_extensions: -ascii_identifiers
      toc: true
      toc_depth: 3
---

# set 

```{r option, echo=FALSE, cache=FALSE, warning=FALSE}
rm(list = ls())
setwd("~/Desktop/circular_reg/") 
library(knitr)
## Global options
options(max.print="75", digits=5)
opts_chunk$set(echo=TRUE,
               cache = TRUE,
	             prompt=FALSE,
               tidy=TRUE,
               comment=NA,
               message=FALSE,
               warning=FALSE)
opts_knit$set(width=75)
```


# install package

```{r,echo=FALSE}
library(dplyr)
library(tidyverse)
library(tibble)
library(lubridate)
library(circular)
library(readr)
library(ggthemes)
library(vars)
library(MASS)
library(rstan)
library(MCMCpack)
library(loo)
library(ggmcmc)
library(magrittr)
```

# Function

```{r}
# Projected Normal Circular Plobability Density 
dPnCircular_dens <- function(theta,mu,Sigma){
 u = matrix(c(cos(theta),sin(theta)),ncol=1)
 A = t(u) %*% solve(Sigma) %*% u
 B = t(u) %*% solve(Sigma) %*% mu
 C = (-1/2) * (t(mu) %*% solve(Sigma) %*% mu)
 tmp = B/sqrt(A)
 p = as.numeric((1/(2*pi*A*sqrt(det(Sigma)))) * exp(C) *
   (1 + tmp*pnorm(tmp,0,1)/dnorm(tmp,0,1)))
 return(p)
}
# Vectorize 関数
v.dPnCircular_dens <- Vectorize(dPnCircular_dens, "theta") 
```

```{r}
# 結果のベクトルを抽出 VAR(p)
# lower(point at 2.5%), upper(point at 97.5%)
ans_stan_p <- function(fit,P,num,data){
  # 得られたモデルを抽出する
  fit_ext <- rstan::extract(fit,permuted=T); 
  # Const parameter
  alpha_0 = matrix(c(fit_ext$alpha_0[,1] %>% mean(),fit_ext$alpha_0[,2] %>% mean()),ncol=1);
  alpha_0_low = matrix(c(fit_ext$alpha_0[,1] %>% quantile(0.025),fit_ext$alpha_0[,2] %>% quantile(0.025)),ncol=1);
  alpha_0_up = matrix(c(fit_ext$alpha_0[,1] %>% quantile(0.975),fit_ext$alpha_0[,2] %>% quantile(0.975)),ncol=1);

  # Beta parameter
  alpha_1 <- alpha_1_low <- alpha_1_up <- c();
  for(i in 1:P){
    tmp <- matrix(c(fit_ext$alpha_1[,1,(2*i-1)] %>% mean(),fit_ext$alpha_1[,1,2*i] %>% mean(),
                    fit_ext$alpha_1[,2,(2*i-1)] %>% mean(),fit_ext$alpha_1[,2,2*i] %>% mean()),byrow=T,2,2)
    alpha_1 <- cbind(alpha_1, tmp)
    tmp <- matrix(c(fit_ext$alpha_1[,1,(2*i-1)] %>% quantile(0.025),fit_ext$alpha_1[,1,2*i] %>% quantile(0.025),
                    fit_ext$alpha_1[,2,(2*i-1)] %>% quantile(0.025),fit_ext$alpha_1[,2,2*i] %>% quantile(0.025)),byrow=T,2,2)
    alpha_1_low <- cbind(alpha_1_low, tmp)
    tmp <- matrix(c(fit_ext$alpha_1[,1,(2*i-1)] %>% quantile(0.975),fit_ext$alpha_1[,1,2*i] %>% quantile(0.975),
                    fit_ext$alpha_1[,2,(2*i-1)] %>% quantile(0.975),fit_ext$alpha_1[,2,2*i] %>% quantile(0.975)),byrow=T,2,2)
    alpha_1_up <- cbind(alpha_1_up, tmp)
  }
  # Variance-Covariance matrix
  Sigma = matrix(c(fit_ext$sigma[,1,1] %>% mean(),fit_ext$sigma[,1,2] %>% mean(),
                   fit_ext$sigma[,2,1] %>% mean(),fit_ext$sigma[,2,2] %>% mean()),byrow=T,2,2)
  Sigma_low = matrix(c(fit_ext$sigma[,1,1] %>% quantile(0.025),fit_ext$sigma[,1,2] %>% quantile(0.025),
                       fit_ext$sigma[,2,1] %>% quantile(0.025),fit_ext$sigma[,2,2] %>% quantile(0.025)),byrow=T,2,2)
  Sigma_up = matrix(c(fit_ext$sigma[,1,1] %>% quantile(0.975),fit_ext$sigma[,1,2] %>% quantile(0.975),
                      fit_ext$sigma[,2,1] %>% quantile(0.975),fit_ext$sigma[,2,2] %>% quantile(0.975)),byrow=T,2,2)

  # Estimate condition mean 
  mu_hat <- mu_hat_low <- mu_hat_up <- matrix(0, ncol=2, nrow=(num-P) )
  for(i in (1+P):num){
    pre <- c(); # p期前のcos(theta), sin(theta)を格納する
    for (k in 1:P) pre <- rbind(pre,matrix(c(cos(data[i-k]),sin(data[i-k])),ncol=1));
    mu_hat[i-P,] <- alpha_0 + ( alpha_1 %*% pre )
    mu_hat_low[i-P,] <- alpha_0_low + ( alpha_1_low %*% pre )
    mu_hat_up[i-P,] <- alpha_0_up + ( alpha_1_up %*% pre )
  }
  # Estimate moment function
  fn.sin<-function(x,mu,Sigma) sin(x)*v.dPnCircular_dens(theta=x, mu, Sigma) # sin func
  fn.cos<-function(x,mu,Sigma) cos(x)*v.dPnCircular_dens(theta=x, mu, Sigma) # cos func
  # Estimate sin and cos value
  len <- dim(mu_hat)[1]; 
  sin.mom <- cos.mom <- sin.mom_low <- cos.mom_low <- sin.mom_up <- cos.mom_up <- c();
  for(i in 1:len){
   sin.mom[i] <- integrate(fn.sin, lower=-pi, upper=pi, mu=mu_hat[i,], Sigma=Sigma)$value
   cos.mom[i] <- integrate(fn.cos, lower=-pi, upper=pi, mu=mu_hat[i,], Sigma=Sigma)$value
   sin.mom_low[i] <- integrate(fn.sin, lower=-pi, upper=pi, mu=mu_hat_low[i,], Sigma=Sigma_low)$value
   cos.mom_low[i] <- integrate(fn.cos, lower=-pi, upper=pi, mu=mu_hat_low[i,], Sigma=Sigma_low)$value
   sin.mom_up[i] <- integrate(fn.sin, lower=-pi, upper=pi, mu=mu_hat_up[i,], Sigma=Sigma_up)$value
   cos.mom_up[i] <- integrate(fn.cos, lower=-pi, upper=pi, mu=mu_hat_up[i,], Sigma=Sigma_up)$value
  }
  # Estimate predict theta value
  pred <- atan2(sin.mom,cos.mom)
  pred_low <- atan2(sin.mom_low,cos.mom_low)
  pred_up <- atan2(sin.mom_up,cos.mom_up)
  return(data.frame(pred = c(rep(NA,P),pred),lower = c(rep(NA,P),pred_low),upper = c(rep(NA,P),pred_up)))  
}
# output predict value
pred_value <- function(fit,p,dat){
  # パラメータ推定値を用いて予測する, 出力はdata.frame形式
  pred <- ans_stan_p(fit, P=p, num = length(dat),data=dat) 
  # model のRMSE 算出するコード
  data.frame(real=dat,pred) %>% 
    mutate(dif = pred - real) %>% 
    mutate(dif_ = dplyr::if_else(dif < -pi, dif + 2*pi,
                                 dplyr::if_else(dif > pi, dif - 2*pi, dif))) %>% # 誤差は必ず -pi ~ pi に含まれる
    mutate(eps = dif_^2) %>% 
    summarise(ans = sqrt(mean(eps,na.rm = TRUE))) %>% 
    sprintf("RMSE of VAR(%d) model = %f",p,.) %>%  print() # Root Mean Square Error
  # 予測値, 真値, 信用区間を表示する
  data.frame(real=dat,pred) %>% 
    mutate(index = row_number()) %>%
    ggplot(aes(index)) +
      geom_line(aes(y=real)) + 
      geom_line(aes(y=pred), color="steelblue") +
      geom_ribbon(aes(ymin=lower,ymax=upper),colour="grey70",alpha=0.5)+
      theme_bw()
}
```

# dataset

```{r}
# dataset we report the wind direction recorded every day from January 29, 2001 to March 31, 2001 from 3.00am to 4.00am included.
# 角度データなので, 周期性を考えて, 0がモード付近になるようにシフトさせる. 元データから$-\pi$ずらして, $[-\pi,\pi]$で考える.
data(wind) 
wind_data <- wind %>%  
  data.frame(t = seq(1,310,1), tmp=.) %>% # put label
  mutate(theta_real = dplyr::if_else(tmp>pi,tmp - 2*pi, tmp)) %>% 
  dplyr::select(-tmp) %>% 
  mutate(cos_real = cos(theta_real), sin_real=sin(theta_real)) 
```

# Basic aggression

```{r,eval=FALSE,include=FALSE}
# 差分を調べてみる
# MSE計算で使える ！！！！！！！！！！！！！！！！！！！！！
wind_dif <- wind_data$theta_real %>% 
  diff() %>% 
  data.frame() %>% 
  mutate(dif = dplyr::if_else(. < -pi, . + 2*pi,
                              dplyr::if_else(. > pi, . - 2*pi, .)))

ts.plot(wind_dif$dif)
ts.plot(wind_data$theta_real)
```

```{r}
# 散布図
plot(wind_data$theta_real[1:309],wind_data$theta_real[2:310])
# 自己相関
acf(wind_data$theta_real^2)
```

```{r}
library(tseries)
# 相互相関
ccf(wind_data$cos_real,wind_data$sin_real,type = "correlation")
# 単位根過程
adf.test(wind_data$theta_real)
```

# check stan funcion

stan 尤度関数が機能しているか確認する

```{r,eval=FALSE,include=FALSE}
rstan::expose_stan_functions("stan/test.stan")
```

```{r likelihood,eval=FALSE,include=FALSE}
# Projected Normal AutoRegressive Process
l_ <- function(arg){
 num <- length(data)
 a0 <- arg[1]; b0 <- arg[4];
 a11 <- arg[2]; a12 <- arg[3]
 b11 <- arg[5]; b12 <- arg[6]
 sigma1 <- exp(arg[7]); sigma2 <- exp(arg[8]); rho <- tanh(arg[9]) # 数値を-1 ~ 1に抑え込む
 sigma <- matrix(c(sigma1^2, rho*sigma1*sigma2,rho*sigma1*sigma2, sigma2^2 ),2,2)
 alpha_0 =  matrix(c(a0,b0), ncol=1); alpha_1 = matrix(c(a11,b11, a12,b12), ncol=2, nrow=2); 
 likelihood <- c(0) 
 for(i in 2:num){
   theta = data[i]; pre_theta = data[i-1]; 
   likelihood <- append(likelihood, circular_reg_lpdf(theta, pre_theta, alpha_0, alpha_1, sigma))
 }
 # print(solve(Sig)) #debug用
 # print(arg[8]) #debug用
 - sum(likelihood) # -1を乗じることで, 最大化問題を最小化問題にする.
}
```

```{r,eval=FALSE,include=FALSE}
#初期値の目安はcircular-circular regressionで
lm.out <- lm.circular(y=wind_data$theta_real[-1], x=wind_data$theta_real[-310],order=1 )
par <- c(lm.out$coefficients[,1], 
         lm.out$coefficients[,2],
         log(var(cos(lm.out$residuals))), # 不偏分散 cos
         log(var(sin(lm.out$residuals))), # 不偏分散 sin
         atanh(cor(cos(lm.out$residuals),sin(lm.out$residuals)))) #相関係数
data=wind_data$theta_real
l_(par)
```

# stan code

## input data list

N: データの長さ, P: ラグ次数, theta: theta の実測値

```{r set data list}
# paramter の値も初期値として入力できるようにした設定用
# para_alpha_1 = 1000, para_alpha_0 = 1000, para_sig = 1000, para_rho = 1000) 
d.dat1 <- list(N=length(wind_data$theta_real),P=1,theta=wind_data$theta_real) # for VAR(1)
d.dat2 <- list(N=length(wind_data$theta_real),P=2,theta=wind_data$theta_real) # for VAR(2)
d.dat3 <- list(N=length(wind_data$theta_real),P=3,theta=wind_data$theta_real) # for VAR(3)
d.dat4 <- list(N=length(wind_data$theta_real),P=4,theta=wind_data$theta_real) # for VAR(4)
d.dat5 <- list(N=length(wind_data$theta_real),P=5,theta=wind_data$theta_real) # for VAR(5)
d.dat10 <- list(N=length(wind_data$theta_real),P=10,theta=wind_data$theta_real) # for VAR(10)
```

```{r stan test, eval=FALSE,include=FALSE}
#fit<-stan(file='stan/test.stan',data=d.dat,iter=1000,chains=1) # sigma(2,2) に対して1を仮定する
#fit<-stan(file='stan/test1.stan',data=d.dat,iter=4000,chains=1) # 分散共分散行列の過程
# compile model
# model1 <- stan_model('stan/circularVAR_p.stan')
# model3 <- stan_model('stan/circularVAR_p_I.stan') # 趣旨とずれる

model1 <- stan_model('stan/circularVAR_p_.stan') # 変化なし
model2 <- stan_model('stan/circularVAR_p_noconst.stan') # no const 
model3 <- stan_model('stan/circularVAR_p_penalty.stan') # 制約なし
model4 <- stan_model('stan/circularVAR_p_sigma_I.stan') # det(sigma) = 1

# fitting stan model
fit1_1 <- sampling(model1, data = d.dat1, iter=1000, chains=1) # Execute model
fit2_1 <- sampling(model1, data = d.dat2, iter=1000, chains=1) # Execute model 
fit1_2 <- sampling(model2, data = d.dat1, iter=1000, chains=1) # Execute model
fit2_2 <- sampling(model2, data = d.dat2, iter=1000, chains=1) # Execute model
fit3_2 <- sampling(model2, data = d.dat3, iter=1000, chains=1) # Execute model
fit1_3 <- sampling(model3, data = c(d.dat1,lambda=0.01), iter=1000, chains=1) # Execute model
fit2_3 <- sampling(model3, data = c(d.dat2,lambda=0.1), iter=1000, chains=1) # Execute model
fit3_3 <- sampling(model3, data = c(d.dat3,lambda=0.1), iter=1000, chains=1) # Execute model
fit1_4 <- sampling(model4, data = d.dat1, iter=1000, chains=1) # Execute model
fit2_4 <- sampling(model4, data = d.dat2, iter=1000, chains=1) # Execute model
fit10_4 <- sampling(model4, data = d.dat10, iter=1000, chains=1) # Execute model

# fit1_5 <- sampling(model5, data = d.dat1, iter=1000, chains=1) # Execute model
# fit2_5 <- sampling(model5, data = d.dat2, iter=1000, chains=1) # Execute model
# fit3_5 <- sampling(model5, data = d.dat3, iter=1000, chains=1) # Execute model
```

## save and load stan code

```{r stan save model and fit,eval=FALSE,include=FALSE}
saveRDS(model1, "model/circularVAR_p_.rds") # save model
saveRDS(model2, "model/circularVAR_p_noconst.rds") # save model
saveRDS(model3, "model/circularVAR_p_penalty.rds") # save model
saveRDS(model4, "model/circularVAR_p_sigma_I.rds") # save model
save(fit1_1, file="fit/circularVAR_1_1.rda")# save fit
save(fit2_1, file="fit/circularVAR_2_1.rda")# save fit
save(fit1_2, file="fit/circularVAR_1_2.rda")# save fit
save(fit2_2, file="fit/circularVAR_2_2.rda")# save fit
## model 4
save(fit1_4, file="fit/circularVAR_1_4.rda")# save fit
save(fit2_4, file="fit/circularVAR_2_4.rda")# save fit
save(fit3_4, file="fit/circularVAR_3_4.rda")# save fit
save(fit4_4, file="fit/circularVAR_4_4.rda")# save fit
save(fit5_4, file="fit/circularVAR_5_4.rda")# save fit
save(fit10_4, file="fit/circularVAR_10_4.rda")# save fit
```

```{r stan load model,eval=FALSE,include=FALSE}
model1 <- readRDS("model/circularVAR_p_.rds") # load model
model2 <- readRDS("model/circularVAR_p_noconst.rds") # load model
model3 <- readRDS("model/circularVAR_p_penalty.rds") # load model
model4 <- readRDS("model/circularVAR_p_sigma_I.rds") # load model
load("fit/circularVAR_1_1.rda", verbose = TRUE) # load fit
load("fit/circularVAR_2_1.rda", verbose = TRUE) # load fit
load("fit/circularVAR_1_2.rda", verbose = TRUE) # load fit
load("fit/circularVAR_2_2.rda", verbose = TRUE) # load fit
```

```{r stan load fit}
load("fit/circularVAR_1_4.rda", verbose = TRUE) # load fit
load("fit/circularVAR_2_4.rda", verbose = TRUE) # load fit
load("fit/circularVAR_3_4.rda", verbose = TRUE) # load fit
load("fit/circularVAR_4_4.rda", verbose = TRUE) # load fit
load("fit/circularVAR_5_4.rda", verbose = TRUE) # load fit
# load("fit/circularVAR_10_4.rda", verbose = TRUE) # load fit
```

## stan parallel processing code

```{r stan Parallel processing, eval=FALSE}
rstan_options(auto_write=TRUE) # auto save
options(mc.cores=parallel::detectCores()) # multi core

### stan code ###  
fit1_4 <- sampling(model4, data = d.dat1, iter = 5000, chains = 4, thin = 5)
fit2_4 <- sampling(model4, data = d.dat2, iter = 5000, chains = 4, thin = 5)
fit3_4 <- sampling(model4, data = d.dat3, iter = 5000, chains = 4, thin = 5)
fit4_4 <- sampling(model4, data = d.dat4, iter = 5000, chains = 4, thin = 5)
fit5_4 <- sampling(model4, data = d.dat5, iter = 5000, chains = 4, thin = 5)
# fit10_4 <- sampling(model4, data = d.dat10, iter = 5000, chains = 4, thin = 5)
```

# output fit paremter

```{r}
options(max.print = 400)
fit1_4 # model4, VAR(1)model
fit2_4 # model4, VAR(2)model
fit3_4 # model4, VAR(3)model
fit4_4 # model4, VAR(4)model
fit5_4 # model4, VAR(5)model
# fit10_4 # model4, VAR(10)model
```

# output predict value

```{r}
# # model1
# pred_value(fit = fit1_1,p = 1,dat=wind_data$theta_real)
# pred_value(fit = fit2_1,p = 2,dat=wind_data$theta_real)
# 
# #model2
# pred_value(fit = fit1_2,p = 1,dat=wind_data$theta_real)
# pred_value(fit = fit2_2,p = 2,dat=wind_data$theta_real)
# pred_value(fit = fit3_2,p = 3,dat=wind_data$theta_real)
# 
# #model3
# pred_value(fit = fit1_3,p = 1,dat=wind_data$theta_real) # function 内部 変更の必要あり
# pred_value(fit = fit2_3,p = 2,dat=wind_data$theta_real) # function 内部 変更の必要あり

#model4
pred_value(fit = fit1_4,p = 1,dat=wind_data$theta_real)
pred_value(fit = fit2_4,p = 2,dat=wind_data$theta_real)
pred_value(fit = fit3_4,p = 3,dat=wind_data$theta_real)
pred_value(fit = fit4_4,p = 4,dat=wind_data$theta_real)
pred_value(fit = fit5_4,p = 5,dat=wind_data$theta_real)
# pred_value(fit = fit10_4,p = 10,dat=wind_data$theta_real)

# # model5
# pred_value(fit = fit1_5,p = 1,dat=wind_data$theta_real)
# pred_value(fit = fit2_5,p = 2,dat=wind_data$theta_real)
# pred_value(fit = fit3_5,p = 3,dat=wind_data$theta_real)
```

# Diagnosis

```{r,eval=FALSE}
shinystan::launch_shinystan(fit1_4) # 基本的な分析これで全て見れる
get_posterior_mean(fit1_4) # chainごとのパラメータ見れる
get_inits(fit1_4) # 要確認
```

# log_likelihood

得られた結果から対数尤度を計算し, サンプリング数に対応する対数尤度のヒストグラム, 対数尤度の最大値, 最小値を示す.

```{r}
extract_likelihood <- function(fit){
  log_lik <- c(); a <- extract_log_lik(fit,"log_likelihood");
  for( i in 1:dim(a)[1]) log_lik <- append(log_lik,a[i,] %>% sum()) 
  sprintf("max log_lik = %f, min log_lik = %f", max(log_lik),min(log_lik)) %>% print()
  hist(log_lik)
}
```

```{r}
extract_likelihood(fit1_4) # VAR(1) model
extract_likelihood(fit2_4) # VAR(2) model
extract_likelihood(fit3_4) # VAR(3) model
extract_likelihood(fit4_4) # VAR(4) model
extract_likelihood(fit5_4) # VAR(5) model
# extract_likelihood(fit10_4) # VAR(10) model
```

# Estimate and waic

各モデルに対する, WAICを計算する. 

```{r}
# model4
extract_log_lik(fit1_4,"log_likelihood") %>% loo::waic() # VAR(1) model
extract_log_lik(fit2_4,"log_likelihood") %>% loo::waic() # VAR(2) model
extract_log_lik(fit3_4,"log_likelihood") %>% loo::waic() # VAR(3) model
extract_log_lik(fit4_4,"log_likelihood") %>% loo::waic() # VAR(4) model
extract_log_lik(fit5_4,"log_likelihood") %>% loo::waic() # VAR(5) model
# extract_log_lik(fit10_4,"log_likelihood") %>% loo::waic() # VAR(10) model
```

```{r,eval=FALSE,include=FALSE}
# model1
log_lik1 <- extract_log_lik(fit1_1,"log_likelihood")
loo::waic(log_lik1)
log_lik2 <- extract_log_lik(fit2_1,"log_likelihood")
loo::waic(log_lik2)

# model2
log_lik1 <- extract_log_lik(fit1_2,"log_likelihood")
loo::waic(log_lik1)
log_lik2 <- extract_log_lik(fit2_2,"log_likelihood")
loo::waic(log_lik2)

# model3
extract_log_lik(fit3_2,"log_likelihood") %>% loo::waic()
extract_log_lik(fit3_5,"log_likelihood") %>% loo::waic()

# model4
log_lik1 <- extract_log_lik(fit4_2,"log_likelihood")
loo::waic(log_lik1)
log_lik2 <- extract_log_lik(fit4_4,"log_likelihood")
loo::waic(log_lik2)

# model5
extract_log_lik(fit2_5,"log_likelihood") %>% loo::waic()
extract_log_lik(fit3_5,"log_likelihood") %>% loo::waic()
```

